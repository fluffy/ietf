<?xml version="1.0" encoding="US-ASCII"?>

<!-- TODO 

fix the flow diagram to show ACK message and switch direction to server-initiate

-->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc5226 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY rfc6347 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY rfc6407 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6407.xml">
<!ENTITY rfc5234 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY rfc2675 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2675.xml">
<!ENTITY rfc4301 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4301.xml">
<!ENTITY rfc2409 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2409.xml">
<!ENTITY rfc2410 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2410.xml">
<!ENTITY rfc2406 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2406.xml">
<!ENTITY rfc2407 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2407.xml">
<!ENTITY rfc3261 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3261.xml">
<!ENTITY rfc3264 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3264.xml">
<!ENTITY rfc5649 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5649.xml">
<!ENTITY rfc4648 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY rfc3550 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3550.xml">
<!ENTITY rfc3610 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3610.xml">
<!ENTITY rfc3602 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3602.xml">
<!ENTITY rfc3686 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3686.xml">
<!ENTITY rfc3830 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3830.xml">
<!ENTITY rfc3711 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3711.xml">
<!ENTITY rfc4563 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4563.xml">
<!ENTITY rfc4771 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4771.xml">
<!ENTITY rfc4567 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4567.xml">
<!ENTITY rfc4568 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4568.xml">
<!ENTITY rfc5764 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5764.xml">
<!ENTITY rfc4566 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4566.xml">
<!ENTITY rfc4086 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4086.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="no" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<rfc category="std" docName="draft-jennings-perc-srtp-ekt-diet-00" ipr="trust200902">
  <front>
    <title abbrev="EKT SRTP">Encrypted Key Transport for Secure RTP</title>

    <author fullname="John Mattsson" initials="J.M" surname="Mattsson" role="editor" >
      <organization abbrev="Ericsson">Ericsson AB</organization>

      <address>
        <postal>
          <street>SE-164 80 Stockholm</street>

          <country>Sweden</country>
        </postal>

        <phone>+46 10 71 43 501</phone>

        <email>john.mattsson@ericsson.com</email>
      </address>
    </author>


    <author fullname="David A. McGrew" initials="D.A.M." surname="McGrew">
      <organization abbrev="Cisco">Cisco Systems</organization>

      <address>
        <postal>
          <street>510 McCarthy Blvd.</street>

          <city>Milpitas</city>

          <region>CA</region>

          <code>95035</code>

          <country>US</country>
        </postal>

        <phone>(408) 525 8651</phone>

        <email>mcgrew@cisco.com</email>

        <uri>http://www.mindspring.com/~dmcgrew/dam.htm</uri>
      </address>
    </author>


    <author fullname="Dan Wing" initials="D." surname="Wing">
      <organization abbrev="Cisco">Cisco Systems</organization>

      <address>
        <postal>
          <street>510 McCarthy Blvd.</street>

          <city>Milpitas</city>

          <region>CA</region>

          <code>95035</code>

          <country>US</country>
        </postal>

        <phone>(408) 853 4197</phone>

        <email>dwing@cisco.com</email>
      </address>
    </author>


    <author fullname="Flemming Andreason" initials="F.A." surname="Andreasen">
      <organization abbrev="Cisco">Cisco Systems</organization>

      <address>
        <postal>
          <street>499 Thornall Street</street>

          <city>Edison</city>

          <region>NJ</region>

          <code>08837</code>

          <country>US</country>
       </postal>

        <email>fandreas@cisco.com</email>
      </address>
    </author>

      <author fullname="Cullen Jennings" initials="C." surname="Jennings">
      <organization abbrev="Cisco">Cisco Systems</organization>

      <address>
        <postal>
        <street></street>

          <city>Calgary</city>

          <region>AB</region>

          <code></code>

          <country>Canada</country>
       </postal>

        <email>fluffy@iii.ca</email>
      </address>
    </author>

      <date month="March" day="19" year="2016"/>


    <area>ART</area>

    <workgroup>PERC Working Group</workgroup>

    <keyword>RTP</keyword>

    <keyword>SRTP</keyword>

    <keyword>EKT</keyword>

    <abstract>

      <t> IMPORTANT: This draft is just a cut down version of
      draft-ietf-avtcore-srtp-ekt-03 to help discussion about the key parts of
      EKT for the PERC WG. Any changes decided here would need to be synchronized with
      the draft-ietf-avtcore-srtp-ekt draft. Nearly all the text here came from
      draft-ietf-avtcore-srtp-ekt and the authors of that draft. </t>
      
      <t>Encrypted Key Transport (EKT) is an extension to Secure Real-time
      Transport Protocol (SRTP) that provides for the secure transport of SRTP
      master keys, Rollover Counters, and other information within
      SRTP.
      This facility enables SRTP to work for decentralized conferences
      with minimal control by allowing a common key to be used across multiple
      endpoints.
      </t>

    </abstract>
    
  </front>

  <middle>
    <section title="Introduction">
      
      <t>RTP is designed to allow decentralized groups with minimal control to
      establish sessions, such as for multimedia conferences.  Unfortunately,
      Secure RTP (<xref target="RFC3711">SRTP</xref>) cannot be used in many
      minimal-control scenarios, because it requires that SSRC values and other
      data be coordinated among all of the participants in a session.  For
      example, if a participant joins a session that is already in progress,
      that participant needs to be told the SRTP keys (and SSRC, ROC and other
      details) of the other SRTP sources.</t>

      <t>The inability of SRTP to work in the absence of central control was
      well understood during the design of the protocol; the omission was
      considered less important than optimizations such as bandwidth
      conservation. Additionally, in many situations SRTP is used in conjunction
      with a signaling system that can provide most of the central control
      needed by SRTP. However, there are several cases in which conventional
      signaling systems cannot easily provide all of the coordination
      required. It is also desirable to eliminate the layer violations that
      occur when signaling systems coordinate certain SRTP parameters, such as
      SSRC values and ROCs.</t>

      <t>This document defines Encrypted Key Transport (EKT) for SRTP and reduces the
      amount of external signaling control that is needed in a SRTP
      session that is shared with multiple receivers. EKT securely distributes the SRTP master key and other
      information for each SRTP source. With this method, SRTP entities are free to choose SSRC
      values as they see fit, and to start up new SRTP sources (SSRC) with new
      SRTP master keys (see Section 2.2) within a session without coordinating
      with other entities via external signaling or other external means. </t>

      <t>EKT provides a way for an SRTP session participant, either a sender or
      receiver, to securely transport its SRTP master key and current SRTP
      rollover counter to the other participants in the session.  This data
      furnishes the information needed by the receiver to
      instantiate an SRTP/SRTCP receiver context.</t>

      <t>EKT does not control the manner in which the SSRC is generated; it is
      only concerned with their secure transport. </t>

      <t>EKT is not intended to replace external key establishment mechanisms,
      Instead, it is used in conjunction with those methods, and it relieves
      them of the burden of tightly coordinating every SRTP source (SSRC) among
      every SRTP participant.</t>

      <section title="Conventions Used In This Document">

        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119"></xref>.</t>

      </section>
    </section>

    <section anchor="normative" title="Encrypted Key Transport">
      
      <t>EKT defines a new method of providing SRTP master keys to an endpoint.
      In order to convey the ciphertext of the SRTP master key, and other
      additional information, an additional EKT field is added to SRTP
      packets.  When added to SRTP, the EKT field appears at the
      end of the SRTP packet, after the authentication tag (if that tag is
      present), or after the ciphertext of the encrypted portion of the packet
      otherwise.</t>

      <t>EKT MUST NOT be used in conjunction with SRTP's MKI (Master Key
      Identifier) or with SRTP's &lt;From, To&gt; <xref
      target="RFC3711"></xref>, as those SRTP features duplicate some of the
      functions of EKT.
      </t>

      <!-- open issue: move the 1,0 to a full byte command at end. Reserve 1
           for pre standard uses -->

        <!-- open issue: Do we need a non encrypted version of the ROC -->
        
      <section anchor="EKT" title="EKT Field Formats">
        
        <t> The EKT Field uses the format defined below for the Full_EKT_Field
        and Short_EKT_Field.  </t>

	<figure anchor="tag_format_base"
                title="Full EKT Field format"
		align="center">
          <artwork align="center">
	    <![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
:                                                               :
:                        EKT Ciphertext                         :
:                                                               :
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Security Parameter Index  |1|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>

	</figure>
	
        <figure anchor="tag_format_abbreviated"
                title="Short EKT Field format"
		align="center">
          <artwork align="center"><![CDATA[
 0 1 2 3 4 5 6 7 
+-+-+-+-+-+-+-+-+
|0 0 0 0 0 0 0|0|
+-+-+-+-+-+-+-+-+
]]></artwork>
        </figure>

	<!--
        <figure anchor="tag_formats"
                title="EKT data formats">
<artwork align="left"><![CDATA[

EKT_Type_Full = 1  
EKT_Type_Short = 0  

EKT_Plaintext = SRTP_Master_Key || SSRC || ROC 

EKT_Ciphertext = EKT_Encrypt(EKT_Key, EKT_Plaintext)

Full_EKT_Field = EKT_Ciphertext || SPI ||  EKT_Type_Full

Short_EKT_Field = '0000000' || EKT_Type_Short

]]></artwork>
        </figure>
	-->
	
        <t>
          <!-- Here || denotes concatenation, and '1' and '0' denote single one and
               zero bits, respectively. -->
	  
	  These fields and data elements are defined
          as follows:
          <list style="hanging">

	        <t hangText="EKT_Plaintext:">The data that is input to the EKT
	        encryption operation.  This data never appears on the wire, and is
	        used only in computations internal to EKT.
	        </t>

	        <t hangText="EKT_Ciphertext:">The data that is output from the EKT
	        encryption operation, described in <xref target="cipher"></xref>.
	        This field is included in SRTP packets when EKT is in use.
	        The length of this field is variable, and is equal to the ciphertext
	        size N defined in <xref target="cipher"></xref>. Note that the
	        length of the field is inferable from the SPI field,
		since the SPI will indicate the cipher being used and
		thus the size.
	        </t>

	        <t hangText="SRTP_Master_Key:">On the sender side, the SRTP Master
	        Key associated with the indicated SSRC.  The length of this field
	        depends on the cipher suite negotiated during call setup for SRTP or
	        SRTCP.</t>

	        <t hangText="SSRC:">On the sender side, this field is the SSRC for
	        this SRTP source.  The length of this field is 32 bits.</t>

            <t hangText="Rollover Counter (ROC):">On the sender side, this field
            is set to the current value of the SRTP rollover counter in the SRTP
            context associated with the SSRC in the SRTP or SRTCP packet.  The
            length of this field is 32 bits.
	        </t>

            <t hangText="Security Parameter Index (SPI):">This field indicates the
            appropriate EKT Key and other parameters for the receiver to use
            when processing the packet. Each time a different EKT Key
	    is received, it will have a different SPI. The length of this field is
            15 bits.  The parameters identified by this field are:

	    <list
		style="symbols">
            
              <t>The EKT cipher used to process the packet.</t>

              <t>The EKT Key used to process the packet.</t>
                      
              <t>The SRTP Master Salt associated with any Master Key
              encrypted with this EKT Key.</t>
	      
            </list>
          
            Together, these data elements are called an EKT parameter set.  Within
            each SRTP session, each distinct EKT parameter set that may be used
            MUST be associated with a distinct SPI value, to avoid ambiguity. 
	    </t>
            
            <t hangText="Final bit:"> The last bit is used to indicate the
            type of the Field. This MUST be 1 in the Full EKT Field
            format and 0 in Short EKT Field.</t>
                  

          </list>
        </t>
        
      </section>

      <section anchor="processing" title="Packet Processing and State Machine">
        
        <t>At any given time, each SRTP/SRTCP source (SSRC) has associated with
        it a single EKT parameter set. This parameter set is used to process all
        outbound packets, and is called the outbound parameter set for
	that SSRC. There may be
        other EKT parameter sets that are used by other SRTP/SRTCP sources in
        the same session, including other SRTP/SRTCP sources on the same
        endpoint (e.g., one endpoint with voice and video might have two EKT
        parameter sets, or there might be multiple video sources on an endpoint
        each with their own EKT parameter set).  All of the received EKT parameter sets
        SHOULD be stored by all of the participants in an SRTP session, for use
        in processing inbound SRTP and SRTCP traffic.</t>

	<t>All SRTP master keys MUST NOT be re-used, MUST be randomly generated
	according to <xref target="RFC4086"></xref>, and MUST NOT be equal to or
	derived from other SRTP master keys.</t>
        
        <t> Either the Full_EKT_Field or Short_EKT_Field is appended
        at the tail end of all the SRTP packet.  </t>
        
        <section anchor="outbound" title="Outbound Processing">

	  <t>See <xref target="timing"></xref> which describes when to send an
	  EKT packet with a Full EKT Field. If a Full EKT Field is not being
          sent, then a Short EKT Field needs to be sent so the receiver can
          correctly
	  determine how to process the packet. </t>

          <t>When an SRTP packet is to be sent with a Full EKT Field, the EKT field for that
          packet is created as follows, or uses an equivalent set of steps.  The
          creation of the EKT field MUST precede the normal SRTP packet
          processing.  </t>

          <t><list style="numbers">
	    
          <t>The Security Parameter Index field is set to the value of the
          Security Parameter Index that is associated with the outbound
          parameter set. </t>

	  <t>The EKT_Plaintext field is computed from the SRTP Master
	  Key, SSRC, and ROC fields, as shown in <xref
	  target="EKT"/>.  The ROC, SRTP Master Key, and SSRC
	  used in EKT processing SHOULD be the same as the one used in
	  the SRTP processing. 
	  <!-- really do me SHOULD not MUST here - ping me to discuss
	       some time - Cullen --> 
	  </t>

          <t>The EKT_Ciphertext field is set to the ciphertext created by
          encrypting the EKT_Plaintext with the EKT cipher, using the EKT Key as
          the encryption key. The encryption process is detailed in <xref
          target="cipher"></xref>.
	  <!-- ADD BACK LATER Implementations MAY cache the value of this
          field to avoid recomputing it for each packet that is sent. -->
	  </t>


	  <t> Then the Full EKT Field is formed using the EKT Ciphertext
	  and the SPI associated with the EKT Key used above.
	  <!-- ADD BACK LATER
	       <list style="empty"> <t> Note: the value of
	       the EKT Ciphertext field is identical in successive packets protected
	       by the same KEK and SRTP master key.  This value MAY be cached by an
	       SRTP sender to minimize computational effort.  </t></list>
	  -->
	  The computed value of the Full EKT Field is written into
	  the packet.  </t>
	  
	  <!-- ADD BACK LATER
          <t>Implementation note: Because of the format of the Full EKT Field, a
          packet containing the Full EKT Field MUST be sent when the ROC changes
          (i.e., every 2^16 packets).</t>
	  -->
	  
	  </list></t>

	  <t> When a packet is sent with the Short EKT Field, the
	  Short EKF Field is simply appended to the packet. </t>
	  
	  
        </section>

        <section anchor="inbound" title="Inbound Processing">
         
          <t> Inbound EKT processing MUST take place prior to the
          usual SRTP or SRTCP processing.   The following steps show
          processing as packets are received in order.
	  </t>

          <t><list style="numbers">
            
	    <t> The final bit is checked to determine which EKT format
	    is in use.  When an SRTP or SRTCP packet contains a Short
	    EKT Field, the Short EKT Field is removed from the packet
	    then normal SRTP or SRTCP processing occurs.  If the
	    packet contains a Full EKT Field, then processing
	    continues as described below.</t>

	    <t>The combination of the SSRC and the Security Parameter Index (SPI) field is used to
	    find which EKT parameter set should be used when
	    processing the packet.  If there is no matching SPI, then the
	    verification function MUST return an indication of
	    authentication failure, and the steps described below are
	    not performed. EKT parameter set contains the EKT Key, EKT
	    Cipher, and SRTP Master Salt. </t>

	    <t> The EKT Ciphertext authentication is checked and
	    it is decrypted, as described in <xref target="cipher"/>, using
	    the EKT Key and EKT Cipher found in the previous step.  If
	    the EKT decryption operation returns an authentication
	    failure, then the packet processing stops.  </t>

	    <!--
	    <t> JUNK THIS The SSRC field output from the decryption operation is
	    compared to the SSRC field from the SRTP header if EKT was
	    received over SRTP, or from the SRTCP header if EKT was
	    received over SRTCP.  If the values of the two fields do
	    not match, then packet processing halts with an indication
	    of failure.  Otherwise, it continues as follows.</t> -->

	    <!-- JUNK THIS <t> If an SRTP context associated with the SSRC in the
	    previous step already exists and the ROC from the
	    EKT_Plaintext is less than the ROC in the SRTP context,
	    then EKT processing halts and the packet is processed as
	    an out-of-order packet (if within the implementation's
	    sliding window) or dropped (as it is a replay).
	    Otherwise, the ROC in the SRTP context is set to the value
	    of the ROC from the EKT_Plaintext, and the SRTP Master Key
	    from the EKT_Plaintext is accepted as the SRTP master key
	    corresponding to the SSRC indicated in the
	    EKT_Plaintext. </t> -->

	    <!-- JUNK THIS 
            <t>If there is already an SRTP crypto context associated
            with the SSRC in the packet, and replay protection is in
            use, then the receiver performs the replay check described
            in Section 3.3.2 of <xref target="RFC3711"></xref>. If the
            EKT fields are conveyed in an RTCP packet, then the packet
            index used in that check is formed from the Rollover
            Counter and the Initial Sequence Number fields in that
            packet. If the EKT fields are conveyed in an SRTP packet,
            then the packet index used in that check is formed from
            the EKT Rollover Counter field and the RTP Sequence Number
            in that packet.</t> -->
	    
	    <t> The resulting EKT Plaintext is parsed as described in
	    <xref target="EKT"/>, to recover the SRTP Master Key,
	    SSRC, and ROC fields. The Master Salt that is assocted
	    with the EKT Keys used to do the decription is also
	    retreived. </t>
		    
	    <t> The SRTP Master Key, ROC, and Master Salt from the
	    prevous step are saved in a
	    map indexed by the SSRC found in the EKT Plaintext and
	    used for any future inbound or about crypto operations on
	    packets with the that SSRC. </t>
	    
            <!-- JUNK THIS <t>The newly accepted SRTP master key, the SRTP parameters
            from the matching parameter set, and the SSRC from the
            packet, are stored in the crypto context associated with
            the SRTP source (SSRC). The SRTP Key Derivation algorithm
            is run in order to compute the SRTP encryption and
            authentication keys, and those keys are stored for use in
            SRTP processing of inbound packets. The Key Derivation
            algorithm takes as input the newly accepted SRTP master
            key, along with the Master Salt from the matching
            parameter set. </t> -->

            <t>At this point, EKT processing has successfully
            completed, and the normal SRTP or SRTCP processing takes
            place including replay protection.

	    <!-- ADD THIS BACK LATER
		 <list style="empty">
		 <t>Implementation note: the value of the EKT Ciphertext
		 field is identical in successive packets protected by
		 the same EKT parameter set and the same SRTP master key,
		 and ROC.  This ciphertext value MAY be cached by an SRTP
		 receiver to minimize computational effort by noting when
		 the SRTP master key is unchanged and avoiding repeating
		 the above steps.</t>
                 </list>  -->
	    
	    </t>
          </list>
        </t>

	<t> Implementation note: the receiver may want to have a
	sliding window to retain old SRTP master keys (and related
	context) for some brief period of time, so that out of order
	packets can be processed as well as packets sent during the
	time keys are changing. </t>
	
	<!-- JUNK THIS 
        <t> If the SSRC field in the packet does correspond to a known
        SRTP source, then the packet is processed as follows, or using
        an equivalent set of steps.

	<list style="numbers">
                  
          <t> The appropriate parameter set is selected using the
          Security Parameter Index field, as in Step 1 above, and the
          EKT Ciphertext field is decrypted using the Key Encrypting Key
          as in Step 2 above.  The resulting plaintext is used as a
          provisional SRTP master key.  </t>
          
          <t> If the provisional key matches the key associated with the
          SSRC, then the packet is processed as follows.  The base
          authentication function is used to check the authenticity of
          the packet, as described in Step 3 above.  If the check
          passes, the packet is accepted, and then the SRTP rollover
          counter is set to the value of the Rollover Counter field.
          </t>
          
          <t> If the provisional key does not match the SRTP master key
          associated with the SRTP source, then processing proceeds as
          follows.  The authenticity of the packet is checked using the
          provisional key and base SRTCP authentication function, as in
          Step 3 above.  If that check passes, then the packet is
          accepted, and the context associated with the SRTP source is
          set as described in Step 5 above.  </t>
	  
	</list>
        </t>
	-->
	

      </section>
    </section>

    <section anchor="cipher" title="Ciphers">
          
          <t>EKT uses an authenticated cipher to encrypt and
	  authenticate the EKT Plaintext. We
          first specify the interface to the cipher, in order to abstract the
          interface away from the details of that function. We then define the
          cipher that is used in EKT by default. The default cipher described in
          <xref target="DefaultCipher"></xref> MUST be implemented, but another
          cipher that conforms to this interface MAY be used, in which case its
          use MUST be coordinated by external means (e.g., key management).</t>

          <!-- JUNK this or ADD ???
	       <t>The SRTP master salt length for the offered cipher suites MUST be the
               same.  In practice the easiest way to achieve this is by offering the
               same crypto suite.</t>
	  -->
	  
	  <!-- OPEN issue : is there a problem with salt lengths when
	       using double -->
	  
          <t>An EKT cipher consists of an encryption function and a decryption
          function. The encryption function E(K, P) takes the following inputs:
          <list style="symbols">
            
            <t>a secret key K with a length of L bytes, and</t>

            <t>a plaintext value P with a length of M bytes.</t>
            
          </list>

          The encryption function returns a ciphertext value C whose length is N
          bytes, where N is at least M.  The decryption function D(K, C) takes
          the following inputs: <list style="symbols">
          
          <t>a secret key K with a length of L bytes, and</t>

          <t>a ciphertext value C with a length of N bytes.</t>

        </list>

        The decryption function returns a plaintext value P that is M bytes
        long, or returns an indication that the decryption operation failed
        because the ciphertext was invalid (i.e. it was not generated by the
        encryption of plaintext with the key K).
	      </t>
          
	      <t>
	        These functions have the property that D(K, E(K, P)) = P for all
	        values of K and P.  Each cipher also has a limit T on the number of
	        times that it can be used with any fixed key value.  For each key,
	        the encryption function MUST NOT be invoked on more than T distinct
	        values of P, and the decryption function MUST NOT be invoked on more
	        than T distinct values of C.</t>

	      <t>Security requirements for EKT ciphers are discussed in <xref
	      target="sec"/>. </t>

          <section anchor="DefaultCipher" title="The Default Cipher">
            
            <t>
	          The default EKT Cipher is the Advanced Encryption Standard (AES)
	          Key Wrap with Padding <xref target="RFC5649"></xref> algorithm.
	          It requires a plaintext length M that is at least one octet, and
	          it returns a ciphertext with a length of N = M + 8 octets.  It can
	          be used with key sizes of L = 16, and 32 octets, and its use with
	          those key sizes is indicated as AESKW_128, or
	          AESKW_256, respectively.  The key size determines the length of
	          the AES key used by the Key Wrap algorithm.  With this cipher,
	          T=2^48.
	        </t>

            <figure anchor="AESKW_table"
                    title="AESKW Table"
		            align="center">
<artwork align="center"><![CDATA[
 length of  length of   
 SRTP         EKT          EKT        EKT        length of
transform   transform    plaintext  ciphertext  Full EKT Field
 ---------  ------------  ---------  ----------  --------------
AES-128    AESKW_128        26          40            42
AES-256    AESKW_256        42          56            58
]]></artwork></figure>

<!-- Open Issue: do we need a AES-192 transform -->

            
	          <t>
	            As AES-128 is the mandatory to implement transform in <xref
	            target="RFC3711">SRTP</xref>, AESKW_128 MUST be implemented for
              EKT.</t>
              
	            <t>For all the SRTP transforms listed in the table, the
	            corresponding EKT transform MUST be used, unless a stronger EKT
	            transform is negotiated by key management.</t>

                
          </section>

          
          <section title="Other EKT Ciphers">
            
            <t>Other specifications may extend this one by defining other EKT
            ciphers per <xref target="iana"></xref>. This section defines how
            those ciphers interact with this specification.</t>

            <t>An EKT cipher determines how the EKT Ciphertext field is written,
            and how it is processed when it is read. This field is opaque to the
            other aspects of EKT processing. EKT ciphers are free to use this
            field in any way, but they SHOULD NOT use other EKT or SRTP fields
            as an input.  The values of the parameters L, M, N, and T MUST be
            defined by each EKT cipher, and those values MUST be inferable from
            the EKT parameter set.</t>
            
          </section>
        </section>

        <section anchor="SynchronizingOperation" title="Synchronizing
                                                        Operation">
          
          <t>If a source has its EKT key changed by the key management, it MUST also
          change its SRTP master key, which will cause it to send out a new Full
          EKT Field.  This ensures that if key management thought the EKT key
          needs changing (due to a participant leaving or joining) and
          communicated that in key management to a source, the source will also
          change its SRTP master key, so that traffic can be decrypted only by
          those who know the current EKT key.</t>

        </section>

        <section anchor="srtp" title="Transport">
          
          <t><!--EKT MUST be used over SRTCP, whenever RTCP is in use.--> EKT
          SHOULD be used over SRTP, and other specification MAY define
	  how to use it over SRTCP.  SRTP is
          preferred because it shares fate with transmitted media, because SRTP
          rekeying can occur without concern for RTCP transmission limits, and
          to avoid SRTCP compound packets with RTP translators and
	  mixers. </t>

        </section>

        <section anchor="timing" title="Timing and Reliability Consideration">

	  <t>A system using EKT learns the SRTP master keys
	  distributed with Full EKT Fields send with the SRTP,
	  rather than with call signaling.  A receiver can immediately decrypt
	  an SRTP provided the SRTP packet
	  contains a Full EKT Field.</t>
	  
          <t>This section describes how to reliably and expediently deliver new
          SRTP master keys to receivers.</t>

          <t>There are three cases to consider.  The first case is a new sender
          joining a session which needs to communicate its SRTP master key to
          all the receivers.  The second case is a sender changing its SRTP
          master key which needs to be communicated to all the receivers.  The
          third case is a new receiver joining a session already in progress
          which needs to know the sender's SRTP master key.</t>

          <t>New sender: A new sender SHOULD send a packet containing the Full
          EKT Field as soon as possible, always before or coincident with
          sending its initial SRTP packet.  To accommodate packet loss, it is
          RECOMMENDED that three consecutive packets contain the Full EKT Field
          be transmitted. </t>

          <t>Rekey: By sending EKT over SRTP, the rekeying event
          shares fate with the SRTP packets protected with that new SRTP master
          key.
	  <!-- ADD LATER To avoid sending large SRTP packets (such as video key frames)
          with the Full EKT Field, it can be advantageous to send smaller SRTP
          packets with the Full EKT Field.-->
	  </t>

          <t>New receiver: When a new receiver joins a session it does not need
          to communicate its sending SRTP master key (because it is a receiver).
          When a new receiver joins a session the
          sender is generally unaware of the receiver joining the session.
          Thus, senders SHOULD periodically transmit the Full EKT Field.  That
          interval depends on how frequently new receivers join the session, the
          acceptable delay before those receivers can start processing SRTP
          packets, and the acceptable overhead of sending the Full EKT Field.
          The RECOMMENDED frequency is the same as the key frame frequency if
          sending video and every 100ms for audio.  </t>


        </section>
      </section>

      <section anchor="dtls-srtp-kt" title="Use of EKT with DTLS-SRTP">
        
        <t>This document defines an extension to DTLS-SRTP called Key Transport.
        The EKT with the DTLS-SRTP Key Transport enables secure transport of EKT
        keying material from one DTLS-SRTP peer to another.  This enables those
        peers to process EKT keying material in SRTP (or SRTCP) and retrieve the
        embedded SRTP keying material.  This combination of protocols is
        valuable because it combines the advantages of DTLS (strong
        authentication of the endpoint and flexibility) with the advantages of
        EKT (allowing secure multiparty RTP with loose coordination and
        efficient communication of per-source keys).</t>

        <section title="DTLS-SRTP Recap">
          
          <t><xref target="RFC5764">DTLS-SRTP</xref> uses an extended DTLS
          exchange between two peers to exchange keying material, algorithms,
          and parameters for SRTP.  The SRTP flow operates over the same
          transport as the DTLS-SRTP exchange (i.e., the same 5-tuple).
          DTLS-SRTP combines the performance and encryption flexibility benefits
          of SRTP with the flexibility and convenience of DTLS-integrated key
          and association management.  DTLS-SRTP can be viewed in two equivalent
          ways: as a new key management method for SRTP, and a new RTP-specific
          data format for DTLS.</t>
        </section>

        <section anchor="dtls-srtp-extensions"
                 title="EKT Extensions to DTLS-SRTP">
          
          <t>This document adds a new TLS negotiated extension called "ekt".
          This adds a new TLS content type, EKT, and a new negotiated extension
          EKT. The DTLS server includes "ekt" in its TLS ServerHello message. If a DTLS
          client includes "ekt" in its ClientHello, but does not receive "ekt"
          in the ServerHello, the DTLS client MUST NOT send DTLS packets with
          the "ekt" content-type.</t>

            <figure anchor="tls_datastructure"
                    title="Additional TLS Data Structures">
              <preamble>Using the syntax described in <xref
              target="RFC6347">DTLS</xref>, the following
              structures are used:</preamble>

<artwork align="center"><![CDATA[
enum {
  ekt_key(0),
  ekt_key_ack(1),
  ekt_key_error(254),
  (255)
} SRTPKeyTransportType;

struct {
  SRTPKeyTransportType keytrans_type;
  uint24 length;
  uint16 message_seq;
  uint24 fragment_offset;
  uint24 fragment_length;
  select (SRTPKeyTransportType) {
     case ekt_key:
        EKTkey;
   };
} KeyTransport;

enum {
 RESERVED(0),
 AESKW_128(1),
 AESKW_256(3),
} ektcipher;

struct {
  ektcipher EKT_Cipher; 
  uint EKT_Key_Value<1..256>;
  uint EKT_Master_Salt<1..256>;
  uint16 EKT_SPI;
} EKTkey;
]]></artwork>
            </figure>

            <t>The diagram below shows a message flow of DTLS client and DTLS
            server using the DTLS-SRTP Key Transport extension. </t>

            <figure anchor="tls_handshake_message_flow"
                    title="Handshake Message Flow">
              <preamble></preamble>
<artwork align="center"><![CDATA[
Client                                               Server

ClientHello + use_srtp + EKT
                             -------->
                              ServerHello + use_srtp + EKT
                                              Certificate*
                                        ServerKeyExchange*
                                       CertificateRequest*
                             <--------     ServerHelloDone
Certificate*
ClientKeyExchange
CertificateVerify*
[ChangeCipherSpec]
Finished                     -------->
                                        [ChangeCipherSpec]
                             <--------            Finished
ekt_key                      --------> 
SRTP packets                 <------->      SRTP packets
SRTP packets                 <------->      SRTP packets
ekt_key (rekey)              --------> 
SRTP packets                 <------->      SRTP packets
SRTP packets                 <------->      SRTP packets
]]></artwork>
            </figure>


        </section>

        <section title="Offer/Answer Considerations">

          <t> When using EKT with DTLS-SRTP, the negotiation to use EKT is done
          at the DTLS handshake level and does not change the <xref
          target="RFC3264"></xref> Offer / Answer messaging. 
          </t>
          
        </section>
      </section>

      <section title="Sending the DTLS EKT_Key Reliably">

	<t> The DTLS ekt_key is sent using the retransmiions specified
	in Section 4.2.4. of <xref target="RFC6347">DTLS</xref>. </t>
      	
      </section>

      <section anchor="sec" title="Security Considerations">
        
        <t>EKT inherits the security properties of the DTLS-SRTP (or
        other) keying it uses.</t>

        <t>With EKT, each SRTP sender and receiver MUST generate distinct SRTP
        master keys. This property avoids any security concern over the re-use
        of keys, by empowering the SRTP layer to create keys on demand. Note
        that the inputs of EKT are the same as for SRTP with key-sharing: a
        single key is provided to protect an entire SRTP session. However, EKT
        remains secure even when SSRC values collide.</t>

        <t>The EKT Cipher includes its own authentication/integrity check. For
        an attacker to successfully forge a full EKT packet, it would need to
        defeat the authentication mechanisms of the EKT Cipher
	authentication mechanism.</t>

        <t> The presence of the SSRC in the EKT_Plaintext ensures that
        an attacker cannot substitute an EKT_Ciphertext from one SRTP
        stream into another SRTP stream.  </t>
        
        <t> An attacker who tampers with the bits in  Full_EKT_Field can prevent the intended receiver of that packet from
        being able to decrypt it.  This is a minor denial of service
        vulnerability.  </t>
  
        <t>An attacker could send packets containing a Full EKT Field,
        in an attempt to consume additional CPU resources of the
        receiving system by causing the receiving system will decrypt
        the EKT ciphertext and detect an authentication failure </t>

        <t>EKT can rekey an SRTP stream until the SRTP rollover counter (ROC)
        needs to roll over.  EKT does not extend SRTP's rollover counter (ROC),
        and like SRTP itself EKT cannot properly handle a ROC rollover.  Thus
        even if using EKT, new (master or session) keys need to be established
        after 2^48 packets are transmitted in a single SRTP stream as described
        in Section 3.3.1 of <xref target="RFC3711"></xref>.  Due to the
        relatively low packet rates of typical RTP sessions, this is not
        expected to be a burden.</t>

        <t>The confidentiality, integrity, and authentication of the EKT cipher
        MUST be at least as strong as the SRTP cipher.</t>
        
        <t> Part of the EKT_Plaintext is known, or easily guessable to
        an attacker.  Thus, the EKT Cipher MUST resist known plaintext
        attacks.  In practice, this requirement does not impose any
        restrictions on our choices, since the ciphers in use provide
        high security even when much plaintext is known.</t>
        
        <t>An EKT cipher MUST resist attacks in which both ciphertexts
        and plaintexts can be adaptively chosen and adversaries that
        can query both the encryption and decryption functions
        adaptively.</t>
        
      </section>

       <section anchor="open-issues" title="Open Issues">
        
         <t> What length should the SPI be?  </t>

	 <t> Should we limit the number of saved SPI for a given SSRC?
	 Or limit the lifetime of old ones after a new one is
	 received? At some level this may not matter because even if
	 the a SRTP packet is injected with an old value, it will be
	 discards by the RTP stack for being old. It is more important
	 that new things are encrypted with the most recent EKT Key.
	 </t>

	 <t> How many bits to differentiate different types of packets
	 and allow for extensibility? </t>

	 <t> Given the amount of old EKT deployed, should the Full EKT
	 use a a different code point than the "1" at the end? </t>

	 <t> Do we need AES-192? </t>
        
       </section>
       
      <section anchor="iana" title="IANA Considerations">
        
        <t> No IANA actions are required. </t>
        
      </section>

      <section title="Acknowledgements">
        
        <t>Thanks to
	David Benham,
        Eddy Lem,
        Felix Wyss,
        Jonathan Lennox,
        Kai Fischer,
        Lakshminath Dondeti,
        Magnus Westerlund,
        Michael Peck,
        Nermeen Ismail,
	Paul Jones,
        Rob Raymond, and
        Yi Cheng
        for fruitful discussions, comments, and contributions to this document.</t>

	<t> This draft is a cut down version of
	draft-ietf-avtcore-srtp-ekt-03 and most of the text here
	came from that draft. </t>
	
      </section>
    </middle>

    <back>
      <references title="Normative References">

        &rfc2119;
        &rfc3711;
        &rfc4086;
        &rfc5649;
        &rfc5764;
        &rfc6347; 
        
      </references>

      <references title="Informative References">
        
        &rfc3264;

      </references>


    </back> </rfc>
